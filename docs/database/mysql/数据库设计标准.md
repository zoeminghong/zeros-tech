# 数据库设计标准

数据库设计标准编写的目的是指导新项目比较高效和合理的开展业务开发工作。

📣 数据库格式类型推荐使用 **utf8mb4（支持emoji），utf8mb4_bin（区分大小写）**。

> 该标准基于 MySQL 进行说明。

## 表结构标准

### 关于常见字段

| 字段        | 推荐类型  |
| ----------- | --------- |
| enable_flag | bit       |
| del_flag    | bit       |
| stauts      | tinyint   |
| create_time | timestamp |
| create_by   |           |
| update_time | timestamp |
| update_by   | --        |

📣 表示【类型】含义的字段推荐使用 kind 代替 type。（type 一般为数据库的特殊单词或保留词）

### 主键

主键最先推荐使用数值类型，可以使用自增长或者雪花；如果存在分库分表的场景首要考虑雪花；

但如果公司要求必须使用字符串类型，推荐使用 UUID、<u>业务字段组合生成</u>；

如果主键ID为自增长类型的场景，不要直接使用ID对外暴露，而是使用无规律的 code 码作为业务含义编码对外提供查询能力。

### 不推荐行为

- text 类型不推荐，推荐使用 varchar(65535) 代替，同时不要添加索引于text类型。

💡在`utf-8`状态下，汉字最多可以存 **21844**个字符串, 英文也为 **21844**个字符串。

- 不要使用外键。
- 不要给可枚举的字段添加索引。
- [索引字段不要设置为 `default NULL`](https://segmentfault.com/a/1190000009540449) 。

### 推荐行为

- 为查询多，插入少的字段添加索引。
- 根据业务要求设置 default 值，不直接使用 `default NULL` 代替了（数据库是最后一道防线）。

## 数据库操作标准

**❓物理删除与逻辑删除的取舍？**

我个人觉得同一个库里面对于表的删除操作也要根据具体场景分别处理，而不能犯懒直接一刀切的方式统一逻辑删除或物理删除。需要发挥各自优势和尽量避免缺点的原则，做表结构的设计。

🔅逻辑删除

逻辑删除有点就是存在后悔药，但随之带来的问题就是唯一索引问题（多个字段组件唯一索引，因为 `del_flag=true` 存在，无法正常使用）、垃圾数据的冗余、操作变的复杂。

> 存在一对多关联关系时，可能会存在列表更新时要判断已存在和未存在的判断的问题，物理删除可以依照条件直接删除，插入最新的数据即可，逻辑删除，就需要判断历史数据与最新数据进行比较。这种场景下，其实比较推荐使用 MongoDB。

- 解决方案
  - del_flag 设置为全局自增长；
  - del_flag 设置为随机数，存在即为删除；
  - 唯一索引使用普通索引，唯一性由程序端处理，高并发的时候要配合乐观锁一起使用；

🔅物理删除

物理删除操作简单，所见即是得，数据更加的直观，缺点就是没有灾备的问题。

- 解决方案
  - 删除操作日志表，类似 binlog 存储思想，将删除前整行数据通过日志表进行记录下来，推荐使用拦截器方式；
  - 延迟删除，为数据设置一个安全期，过了这个安全期就执行物理删除操作，删除没有用的数据（源于Redis惰性删除）；

### 推荐行为

- 不要使用 `select *` 。







## 表设计规约

- varchar类型使用空字符串代替NULL
- 数值类型使用0代替NULL
- 禁止使用枚举类型
- 命名应使用常用英文词汇或者缩写，一律使用小写。多个单词组成的，以下划线(_)分隔开来
- 存在字段注释
- create_time，create_by，update_time，update_by，is_deleted必须存在
- 原则上每张表都应有主键，主键使用自增长
- 单表字段不能超过30个
- 数据库默认字符编码设置为UTF8，默认存储引擎为INNODB

## 索引设计规约

- 普通索引，以idx_开头，连接列名，如idx_mobile。唯一索引，以unq_开头，连接列名，如unq_id_card。
- 值范围重复的比例少的列，适合作为建立索引字段。值范围重复比率高的字段不适合建立索引
- 慎用联合索引。某些情况下，联合索引可能失效，甚至可能导致执行计划异常。创建联合索引前，应经过反复的测试
- 日期时间，不要设置索引，不会生效，而且

## SQL编写规约

- 避免单SQL语句join过多数量表，尽可能将表总数控制在5张以下！--符合
- 应用程序中的SQL语句，禁止一切DDL、DCL操作，例如：create、drop、alter、grant、remove等
- 不要出现select *类似的代码，明确指定字段名，且仅选择必需的字段
- 避免在where子句中对字段进行函数运算。如`date_format(p.payment_date, '%Y-%m-%d') >= date_format('2015-10-10', '%Y-%m-%d')`，这样会使索引失效
- 避免多余的排序，使用group by的时候，默认会进行排序。若不需要排序，可以使用order by null。

