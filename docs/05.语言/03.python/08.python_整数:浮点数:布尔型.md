---
title: python_整数:浮点数:布尔型
date: 2021-02-08 09:57:38
permalink: /pages/2f5691/
categories: 
  - 语言
  - python
tags: 
  - null
comment: true
---
# 整数和浮点数

Python支持对整数和浮点数直接进行四则混合运算，运算规则和数学上的四则运算规则完全一致。

基本的运算：

```python
1 + 2 + 3   # ==> 6
4 * 5 - 6   # ==> 14
7.5 / 8 + 2.1   # ==> 3.0375
```

使用括号可以提升优先级，这和数学运算完全一致，注意只能使用小括号，但是括号可以嵌套很多层：

```python
(1 + 2) * 3    # ==> 9
(2.2 + 3.3) / (1.5 * (9 - 0.3))    # ==> 0.42145593869731807
```

和数学运算不同的地方是，Python的整数运算结果仍然是整数，浮点数运算结果仍然是浮点数：

```python
1 + 2    # ==> 整数 3
1.0 + 2.0    # ==> 浮点数 3.0
```

但是整数和浮点数混合运算的结果就变成浮点数了：

```python
1 + 2.0    # ==> 浮点数 3.0
```

为什么要区分整数运算和浮点数运算呢？这是因为整数运算的结果永远是精确的，而浮点数运算的结果不一定精确，因为计算机内存再大，也无法精确表示出无限循环小数，比如` 0.1 `换成二进制表示就是无限循环小数。

那整数的除法运算遇到除不尽的时候，结果难道不是浮点数吗？我们来试一下：

```python
11 / 4    # ==> 2
```

令很多初学者惊讶的是，Python的整数除法，即使除不尽，结果仍然是整数，余数直接被扔掉。不过，Python提供了一个求余的运算 % 可以计算余数：

```python
11 % 4    # ==> 3
```

如果我们要计算 11 / 4 的精确结果，按照“整数和浮点数混合运算的结果是浮点数”的法则，把两个数中的一个变成浮点数再运算就没问题了：

```python
11.0 / 4    # ==> 2.75
```

## 布尔类型

我们已经了解了Python支持布尔类型的数据，布尔类型只有`True`和`False`两种值，但是布尔类型有以下几种运算：

**与运算**：只有两个布尔值都为 True 时，计算结果才为 True。

```python
True and True   # ==> True
True and False   # ==> False
False and True   # ==> False
False and False   # ==> False
```

**或运算**：只要有一个布尔值为 True，计算结果就是 True。

```python
True or True   # ==> True
True or False   # ==> True
False or True   # ==> True
False or False   # ==> False
```

**非运算**：把True变为False，或者把False变为True：

```python
not True   # ==> False
not False   # ==> True
```

布尔运算在计算机中用来做条件判断，根据计算结果为True或者False，计算机可以自动执行不同的后续代码。

在Python中，布尔类型还可以与其他数据类型做 and、or和not运算，请看下面的代码：

```python
a = True
print a and 'a=T' or 'a=F'
```

计算结果不是布尔类型，而是字符串 'a=T'，这是为什么呢？

因为Python把`0`、`空字符串''`和`None`看成 False，其他数值和非空字符串都看成 True，所以：

```python
True and 'a=T' 计算结果是 'a=T'
继续计算 'a=T' or 'a=F' 计算结果还是 'a=T'
```

**要解释上述结果，又涉及到 and 和 or 运算的一条重要法则：短路计算。**

\1. 在计算` a and b `时，如果 a 是 False，则根据与运算法则，整个结果必定为 False，因此返回 a；如果 a 是 True，则整个计算结果必定取决与 b，因此返回 b。

\2. 在计算` a or b `时，如果 a 是 True，则根据或运算法则，整个计算结果必定为 True，因此返回 a；如果 a 是 False，则整个计算结果必定取决于 b，因此返回 b。

所以Python解释器在做布尔运算时，只要能提前确定计算结果，它就不会往后算了，直接返回结果。